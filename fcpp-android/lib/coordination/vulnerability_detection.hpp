// Copyright Â© 2023 Giorgio Audrito. All Rights Reserved.

/**
 * @file general.hpp
 * @brief Aggregate function tracking the basic functioning of the device.
 */

#ifndef FCPP_COORDINATION_VULNERABILITY_DETECTION_H_
#define FCPP_COORDINATION_VULNERABILITY_DETECTION_H_

#include <cassert>

#include "lib/beautify.hpp"
#include "lib/coordination.hpp"


/**
 * @brief Namespace containing all the objects in the FCPP library.
 */
namespace fcpp {


//! @brief Tag for the vulnerability detection experiment.
struct vulnerability_detection {};


//! @brief Namespace containing the libraries of coordination routines.
namespace coordination {

//! @brief Tags used in the node storage.
namespace tags {
    //! @brief Maximum diameter in hops for a deployment.
    struct diameter {};
    //! @brief The degree of the node.
    struct degree {};
    //! @brief Minimum UID in the network.
    struct min_uid {};
    //! @brief Distance in hops to the device with minimum UID.
    struct hop_dist {};
    //! @brief Whether the current device has only one neighbour.
    struct im_weak {};
    //! @brief Whether some device in the network has only one neighbour.
    struct some_weak {};
}

//! @brief Export list for each experiment.
template <typename> struct experiment_t;
//! @brief Storage list for each experiment.
template <typename> struct experiment_s;

//! @brief Computes whether there is a node with only one connected neighbour at a given time.
FUN void experiment(ARGS, vulnerability_detection) { CODE
    using namespace tags;
    int diameter = node.storage(tags::diameter{});
    node.storage(degree{}) = node.size() - 1;
    node.storage(im_weak{}) = node.size() <= 2;
    tie(node.storage(min_uid{}), node.storage(hop_dist{})) = diameter_election_distance(CALL, diameter);
    bool collect_weak = sp_collection(CALL, node.storage(hop_dist{}), node.size() <= 2, false, [](bool x, bool y) {
        return x or y;
    });
    node.storage(some_weak{}) = broadcast(CALL, node.storage(hop_dist{}), collect_weak);
}
//! @brief Export list for the vulnerability detection experiment.
template <>
struct experiment_t<vulnerability_detection> : export_list<
    diameter_election_distance_t<>, sp_collection_t<hops_t, bool>, broadcast_t<hops_t, bool>
> {};
//! @brief Storage list for the vulnerability detection experiment.
template <>
struct experiment_s<vulnerability_detection> : storage_list<
    tags::degree,         int8_t,
    tags::min_uid,        device_t,
    tags::hop_dist,       hops_t,
    tags::im_weak,        bool,
    tags::some_weak,      bool,
    tags::diameter,       hops_t
> {};

} // namespace coordination

} // namespace fcpp

#endif  // FCPP_COORDINATION_VULNERABILITY_DETECTION_H_
