// Copyright Â© 2023 Giorgio Audrito. All Rights Reserved.

/**
 * @file vulnerability_detection.hpp
 * @brief Experiment computing whether there is a node with only one connected neighbour at any time.
 */

#ifndef FCPP_COORDINATION_VULNERABILITY_DETECTION_H_
#define FCPP_COORDINATION_VULNERABILITY_DETECTION_H_

#include "lib/coordination/experiment_helper.hpp"
#include "lib/coordination/slcs.hpp"
#include "lib/coordination/movement.hpp"
#include "lib/coordination/tracker.hpp"


/**
 * @brief Namespace containing all the objects in the FCPP library.
 */
namespace fcpp {


//! @brief Tag for the vulnerability detection experiment.
struct vulnerability_detection {};


//! @brief Namespace containing the libraries of coordination routines.
namespace coordination {

//! @brief Tags used in the node storage.
namespace tags {
    //! @brief The degree of the node.
    struct degree {};
    //! @brief Minimum UID in the network.
    struct min_uid {};
    //! @brief Distance in hops to the device with minimum UID.
    struct hop_dist {};
    //! @brief Whether the current device has only one neighbour.
    struct im_weak {};
    //! @brief Whether some device in the network has only one neighbour.
    struct some_weak {};
}


//! @brief Simulation logic of the vulnerability detection experiment.
FUN void experiment_simulation(ARGS, vulnerability_detection, common::bool_pack<true>) { CODE
    using namespace tags;
    vec<2> low = {0, 0};
    vec<2> hi = {hi_x, hi_y};
    rectangle_walk(CALL, low, hi, 1.4, node.storage(round_period{}));
    bool leader = node.storage(hop_dist{}) == 0;
    node.storage(node_size{}) = leader ? 2 : 1;
    node.storage(node_shape{}) = leader ? shape::cube : shape::sphere;
    node.storage(node_color{}) = node.storage(im_weak{}) ? color(RED) : node.storage(some_weak{}) ? color(GOLD) : color(GREEN);
}
//! @brief Export list for the simulation logic of the vulnerability detection experiment.
template <>
struct experiment_simulation_t<vulnerability_detection, true> : export_list<
    rectangle_walk_t<2>
> {};
//! @brief Storage list for the simulation logic of the vulnerability detection experiment.
template <>
struct experiment_simulation_s<vulnerability_detection, true> : storage_list<
    experiment_simulation_base_s
> {};


//! @brief Computes whether there is a node with only one connected neighbour at a given time.
GEN(S) void experiment(ARGS, vulnerability_detection, S) { CODE
    using namespace tags;
    int diameter = node.storage(tags::diameter{});
    node.storage(degree{}) = node.size() - 1;
    node.storage(im_weak{}) = node.size() <= 2;
    tie(node.storage(min_uid{}), node.storage(hop_dist{})) = diameter_election_distance(CALL, diameter);
    bool collect_weak = mp_collection(CALL, node.storage(hop_dist{}), node.size() <= 2, false, [](bool x, bool y) {
        return x or y;
    }, [](bool x, size_t) {
        return x;
    });
    node.storage(some_weak{}) = broadcast(CALL, node.storage(hop_dist{}), collect_weak);
    experiment_simulation(CALL, vulnerability_detection{}, S{});
}
//! @brief Export list for the vulnerability detection experiment.
template <bool simulation>
struct experiment_t<vulnerability_detection, simulation> : export_list<
    experiment_simulation_t<vulnerability_detection, simulation>,
    diameter_election_distance_t<>, sp_collection_t<hops_t, bool>, broadcast_t<hops_t, bool>
> {};
//! @brief Storage list for the vulnerability detection experiment.
template <bool simulation>
struct experiment_s<vulnerability_detection, simulation> : storage_list<
    experiment_simulation_s<vulnerability_detection, simulation>,
    tags::degree,         int8_t,
    tags::min_uid,        device_t,
    tags::hop_dist,       hops_t,
    tags::im_weak,        bool,
    tags::some_weak,      bool,
    tags::diameter,       hops_t
> {};
//! @brief Aggregator list for the vulnerability detection experiment.
template <>
struct experiment_a<vulnerability_detection> : storage_list<
    tags::degree,         aggregator::mean<double>,
    tags::im_weak,        aggregator::mean<double>,
    tags::some_weak,      aggregator::mean<double>
> {};
//! @brief Plot list for the vulnerability detection experiment.
template <typename A>
struct experiment_p<vulnerability_detection,A> : public plot::split<plot::time, plot::values<A, common::type_sequence<>, tags::im_weak, tags::some_weak>> {};

} // namespace coordination

} // namespace fcpp

#endif  // FCPP_COORDINATION_VULNERABILITY_DETECTION_H_
